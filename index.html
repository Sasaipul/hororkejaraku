<!DOCTYPE html>
<html>
<head>
    <title>Kejar Aku</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #fff; pointer-events: none; z-index: 10; }
        #minimap {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 160px;
            border: 2px solid #444; background: rgba(0,0,0,0.8);
            border-radius: 5px; overflow: hidden;
        }
        #p-dot, #e-dot { position: absolute; width: 6px; height: 6px; border-radius: 50%; }
        #p-dot { background: #00ff00; }
        #e-dot { background: red; }
        .wall-ui { position: absolute; background: #222; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>MISI: AMBIL 3 INTI (wasd untuk bergerak) </h1>
        <h2 id="score">INTI: 0/3</h2>
        <p>Senter (F) | AInya pinter lho Bang</p>
    </div>
    <div id="minimap"><div id="p-dot"></div><div id="e-dot"></div></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 1, 40);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const CELL_SIZE = 6;
        const walls = [];
        const objectives = [];
        let score = 0;

        const mazeLayout = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,2,0,0,1,0,0,3,0,1],
            [1,1,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,0,1,0,0,1],
            [1,0,1,1,1,0,1,0,1,1],
            [1,3,1,0,0,0,0,0,0,1],
            [1,0,1,0,1,1,1,1,0,1],
            [1,0,0,0,1,3,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];

        mazeLayout.forEach((row, z) => {
            row.forEach((cell, x) => {
                const posX = x * CELL_SIZE; const posZ = z * CELL_SIZE;
                if (cell === 1) {
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(CELL_SIZE, 6, CELL_SIZE), new THREE.MeshStandardMaterial({ color: 0x000000 }));
                    wall.position.set(posX, 3, posZ); scene.add(wall); walls.push(wall);
                    const wUI = document.createElement('div'); wUI.className='wall-ui'; wUI.style.width='14px'; wUI.style.height='14px'; wUI.style.left=(x*16)+'px'; wUI.style.top=(z*16)+'px';
                    document.getElementById('minimap').appendChild(wUI);
                } else if (cell === 3) {
                    const obj = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                    obj.position.set(posX, 1, posZ); scene.add(obj); objectives.push(obj);
                } else if (cell === 2) { camera.position.set(posX, 1.6, posZ); }
            });
        });

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x050505 }));
        floor.rotation.x = -Math.PI/2; floor.position.set(27,0,27); scene.add(floor);

        const flashlight = new THREE.SpotLight(0xffffff, 150, 40, Math.PI/5, 0.3);
        scene.add(flashlight); scene.add(flashlight.target);

        const enemy = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 1.2), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        enemy.position.set(48, 1.25, 48); 
        scene.add(enemy);
        const eLight = new THREE.PointLight(0xff0000, 60, 15); scene.add(eLight);

        function checkCollision(pos, radius) {
            for (let w of walls) {
                const closestX = Math.max(w.position.x - CELL_SIZE/2, Math.min(pos.x, w.position.x + CELL_SIZE/2));
                const closestZ = Math.max(w.position.z - CELL_SIZE/2, Math.min(pos.z, w.position.z + CELL_SIZE/2));
                const dx = pos.x - closestX; const dz = pos.z - closestZ;
                if ((dx*dx + dz*dz) < (radius * radius)) return true;
            }
            return false;
        }

        let keys = {};
        window.onkeydown=(e)=>{ keys[e.code]=true; if(e.code==='KeyF') flashlight.intensity=flashlight.intensity?0:150; };
        window.onkeyup=(e)=>keys[e.code]=false;
        
        let yaw=0, pitch=0;
        window.onmousemove=(e)=>{ 
            if(document.pointerLockElement){ 
                yaw -= e.movementX * 0.002; 
                pitch -= e.movementY * 0.002; 
                pitch = Math.max(-Math.PI/2.1, Math.min(Math.PI/2.1, pitch)); 
            }
        };
        window.onmousedown=()=>document.body.requestPointerLock();

        function animate() {
            requestAnimationFrame(animate);
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            const sDir = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            
            const speed = 0.12;
            let moveX = 0, moveZ = 0;
            if(keys['KeyW']) { moveX += dir.x * speed; moveZ += dir.z * speed; }
            if(keys['KeyS']) { moveX -= dir.x * speed; moveZ -= dir.z * speed; }
            if(keys['KeyA']) { moveX -= sDir.x * speed; moveZ -= sDir.z * speed; }
            if(keys['KeyD']) { moveX += sDir.x * speed; moveZ += sDir.z * speed; }

            if(!checkCollision(new THREE.Vector3(camera.position.x + moveX, 1.6, camera.position.z), 0.7)) camera.position.x += moveX;
            if(!checkCollision(new THREE.Vector3(camera.position.x, 1.6, camera.position.z + moveZ), 0.7)) camera.position.z += moveZ;

            flashlight.position.copy(camera.position);
            flashlight.target.position.copy(camera.position).add(dir);

            // --- SMART AI MOVEMENTS ---
            const eSpeed = 0.04 + (score * 0.012);
            let toPlayer = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
            
            // Coba jalan ke arah player
            let testPos = enemy.position.clone().addScaledVector(toPlayer, eSpeed);
            
            if (!checkCollision(testPos, 0.6)) {
                // Jika tidak ada halangan, jalan lurus
                enemy.position.copy(testPos);
            } else {
                // Jika terhalang, coba lari ke samping (Raycasting sederhana)
                let leftDir = new THREE.Vector3(-toPlayer.z, 0, toPlayer.x); // Vektor tegak lurus
                let rightDir = new THREE.Vector3(toPlayer.z, 0, -toPlayer.x);
                
                let testLeft = enemy.position.clone().addScaledVector(leftDir, eSpeed);
                let testRight = enemy.position.clone().addScaledVector(rightDir, eSpeed);
                
                if (!checkCollision(testLeft, 0.6)) {
                    enemy.position.copy(testLeft);
                } else if (!checkCollision(testRight, 0.6)) {
                    enemy.position.copy(testRight);
                }
            }
            eLight.position.copy(enemy.position);

            // Gameplay Logic
            objectives.forEach((obj, i) => {
                if(camera.position.distanceTo(obj.position) < 1.5) {
                    scene.remove(obj); objectives.splice(i, 1);
                    score++; document.getElementById('score').innerText = `INTI: ${score}/3`;
                    if(score>=3) { alert("MENANG!"); location.reload(); }
                }
            });
            if(camera.position.distanceTo(enemy.position) < 1.6) { alert("MATI!"); location.reload(); }

            document.getElementById('p-dot').style.left = (camera.position.x/6*16)+'px';
            document.getElementById('p-dot').style.top = (camera.position.z/6*16)+'px';
            document.getElementById('e-dot').style.left = (enemy.position.x/6*16)+'px';
            document.getElementById('e-dot').style.top = (enemy.position.z/6*16)+'px';

            renderer.render(scene, camera);
        }
        scene.add(new THREE.AmbientLight(0xffffff, 0.01));
        animate();
    </script>
</body>
</html>